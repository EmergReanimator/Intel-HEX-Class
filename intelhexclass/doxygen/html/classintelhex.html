<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Intel Hex Encoder/Decoder Class: intelhex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>intelhex Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="intelhex" -->
<p>Class to decode, encode and manipulate Intel HEX format files.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="intelhexclass_8hpp_source.html">intelhexclass.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for intelhex:</div>
<div class="dyncontent">
<div class="center"><img src="classintelhex__coll__graph.png" border="0" usemap="#intelhex_coll__map" alt="Collaboration graph"/></div>
<map name="intelhex_coll__map" id="intelhex_coll__map">
<area shape="rect" id="node4" title="STL class." alt="" coords="55,85,140,115"/><area shape="rect" id="node6" title="STL class." alt="" coords="5,5,189,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classintelhex-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b1119e14a960ea2b356967244aafb3"></a><!-- doxytag: member="intelhex::begin" ref="ab2b1119e14a960ea2b356967244aafb3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7759926596cfcffec94e391fff4298e9"></a><!-- doxytag: member="intelhex::end" ref="a7759926596cfcffec94e391fff4298e9" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83b54457c121b0f35b21b78fa2ecd712"></a><!-- doxytag: member="intelhex::jumpTo" ref="a83b54457c121b0f35b21b78fa2ecd712" args="(unsigned long address)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>jumpTo</b> (unsigned long address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a631d8930daeaf04bf0d9ad9c25679a0b"></a><!-- doxytag: member="intelhex::currentAddress" ref="a631d8930daeaf04bf0d9ad9c25679a0b" args="()" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>currentAddress</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab78b6ecc1fd3889bfb0c3bb57f028a64"></a><!-- doxytag: member="intelhex::startAddress" ref="ab78b6ecc1fd3889bfb0c3bb57f028a64" args="()" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>startAddress</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7692acb24330da3debf8c7fb21ab056"></a><!-- doxytag: member="intelhex::endAddress" ref="af7692acb24330da3debf8c7fb21ab056" args="()" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>endAddress</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00e0fd557bec34d0bb11ef92530121a0"></a><!-- doxytag: member="intelhex::getData" ref="a00e0fd557bec34d0bb11ef92530121a0" args="()" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>getData</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71096983db3c24a5ac9b95663937a4ce"></a><!-- doxytag: member="intelhex::insertData" ref="a71096983db3c24a5ac9b95663937a4ce" args="(unsigned char data)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>insertData</b> (unsigned char data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de5cf10103fc307127f9017f3e5cd76"></a><!-- doxytag: member="intelhex::blankFill" ref="a5de5cf10103fc307127f9017f3e5cd76" args="(unsigned char data)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>blankFill</b> (unsigned char data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84bbd449bb55e218b62ea73e2b399196"></a><!-- doxytag: member="intelhex::blankFill" ref="a84bbd449bb55e218b62ea73e2b399196" args="(unsigned char *const data, unsigned long sizeOfData)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>blankFill</b> (unsigned char *const data, unsigned long sizeOfData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf6f77af7a82623ef16471f105ac3fe7"></a><!-- doxytag: member="intelhex::blankFill" ref="aaf6f77af7a82623ef16471f105ac3fe7" args="(unsigned char *const data, unsigned long sizeOfData, unsigned long endAddress)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>blankFill</b> (unsigned char *const data, unsigned long sizeOfData, unsigned long endAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c26ba3dc9dd4f3021bb6c7f6983388f"></a><!-- doxytag: member="intelhex::blankFillRandom" ref="a9c26ba3dc9dd4f3021bb6c7f6983388f" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>blankFillRandom</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1dbcbf3df1aaafd518882c882f43f76"></a><!-- doxytag: member="intelhex::blankFillRandom" ref="aa1dbcbf3df1aaafd518882c882f43f76" args="(unsigned long endAddress)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>blankFillRandom</b> (unsigned long endAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5c67fccc34c78e6dbd28f4b795fb0f"></a><!-- doxytag: member="intelhex::blankFillAddressLowByte" ref="a2e5c67fccc34c78e6dbd28f4b795fb0f" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>blankFillAddressLowByte</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7b16f457563da93569b9812fafb9e7d"></a><!-- doxytag: member="intelhex::blankFillAddressLowByte" ref="ab7b16f457563da93569b9812fafb9e7d" args="(unsigned long endAddress)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>blankFillAddressLowByte</b> (unsigned long endAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6a0119a04a2090af3ffe8c33a37cbc9"></a><!-- doxytag: member="intelhex::verboseOn" ref="ac6a0119a04a2090af3ffe8c33a37cbc9" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>verboseOn</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3958f077a662291bbde3472ea2bcfb4d"></a><!-- doxytag: member="intelhex::verboseOff" ref="a3958f077a662291bbde3472ea2bcfb4d" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>verboseOff</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ae0e9a75bdfaa50d6d0266bb3d56ed1"></a><!-- doxytag: member="intelhex::ihWarnings" ref="a0ae0e9a75bdfaa50d6d0266bb3d56ed1" args="" -->
list&lt; string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ihWarnings</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ea3789cc9ea71c9b35322aabca05158"></a><!-- doxytag: member="intelhex::noOfWarnings" ref="a5ea3789cc9ea71c9b35322aabca05158" args="" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>noOfWarnings</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76fb4550b43dfbb08018cabf34298400"></a><!-- doxytag: member="intelhex::ihErrors" ref="a76fb4550b43dfbb08018cabf34298400" args="" -->
list&lt; string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ihErrors</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a451b78972165b898e91a129670fce919"></a><!-- doxytag: member="intelhex::noOfErrors" ref="a451b78972165b898e91a129670fce919" args="" -->
unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>noOfErrors</b></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#aad8e829c665b49d225a9d0dc48c1fe3c">operator&lt;&lt;</a> (ostream &amp;dataOut, const <a class="el" href="classintelhex.html">intelhex</a> &amp;ihLocal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">istream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintelhex.html#a73fb9c5b9d6d069b5eb83340942fd54b">operator&gt;&gt;</a> (istream &amp;dataIn, <a class="el" href="classintelhex.html">intelhex</a> &amp;ihLocal)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class to decode, encode and manipulate Intel HEX format files. </p>
<p>The Intel HEX class allows the user to stream in the content of an Intel HEX file so that its content can by analysed more easily than trying to decode the Intel HEX file in a text editor. In conjunction with a suitable application it is possible to create content, analyse content and even compare the content of files with one another. </p>

<p>Definition at line <a class="el" href="intelhexclass_8hpp_source.html#l00083">83</a> of file <a class="el" href="intelhexclass_8hpp_source.html">intelhexclass.hpp</a>.</p>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aad8e829c665b49d225a9d0dc48c1fe3c"></a><!-- doxytag: member="intelhex::operator&lt;&lt;" ref="aad8e829c665b49d225a9d0dc48c1fe3c" args="(ostream &amp;dataOut, const intelhex &amp;ihLocal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classintelhex.html">intelhex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ihLocal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output stream overload operator Operator overloaded to encode any data held in memory into the Intel HEX format for storage on disk</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classintelhex.html#a73fb9c5b9d6d069b5eb83340942fd54b">operator&gt;&gt;()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dataOut</em>&nbsp;</td><td>- Output stream for to store the decoded file information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ihLocal</em>&nbsp;</td><td>- Points to this class so that friend function has access to private class members </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73fb9c5b9d6d069b5eb83340942fd54b"></a><!-- doxytag: member="intelhex::operator&gt;&gt;" ref="a73fb9c5b9d6d069b5eb83340942fd54b" args="(istream &amp;dataIn, intelhex &amp;ihLocal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&nbsp;</td>
          <td class="paramname"> <em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classintelhex.html">intelhex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ihLocal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Input stream overload operator Operator overloaded to decode data streamed in from a file in the Intel HEX format into memory</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classintelhex.html#aad8e829c665b49d225a9d0dc48c1fe3c">operator&lt;&lt;()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dataIn</em>&nbsp;</td><td>- Input stream for the encoded file information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ihLocal</em>&nbsp;</td><td>- Points to this class so that friend function has access to private class members </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="intelhexclass_8cpp_source.html#l00211">211</a> of file <a class="el" href="intelhexclass_8cpp_source.html">intelhexclass.cpp</a>.</p>

<p><div class="fragment"><pre class="fragment">{
    <span class="comment">// Create a string to store lines of Intel Hex info</span>
    <span class="keywordtype">string</span> ihLine;
    <span class="comment">/* Create a string to store a single byte of Intel HEX info               */</span>
    <span class="keywordtype">string</span> ihByte;
    <span class="comment">// Create an iterator for this variable</span>
    string::iterator ihLineIterator;
    <span class="comment">// Create a line counter</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> lineCounter = 0;
    <span class="comment">// Variable to hold a single byte (two chars) of data</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteRead;
    <span class="comment">// Variable to calculate the checksum for each line</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> intelHexChecksum;
    <span class="comment">// Variable to hold the record length</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> recordLength;
    <span class="comment">// Variable to hold the load offset</span>
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> loadOffset;
    <span class="comment">// Variables to hold the record type</span>
    intelhexRecordType recordType;
    
    <span class="keywordflow">do</span>
    {
        <span class="comment">/* Clear the string before this next round                            */</span>
        ihLine.erase();
        
        <span class="comment">/* Clear the checksum before processing this line                     */</span>
        intelHexChecksum = 0;
        
        <span class="comment">/* Get a line of data                                                 */</span>
        dataIn &gt;&gt; ihLine;
        
        <span class="comment">/* If the line contained some data, process it                        */</span>
        <span class="keywordflow">if</span> (ihLine.length() &gt; 0)
        {
            <span class="comment">/* Increment line counter                                         */</span>
            lineCounter++;
        
            <span class="comment">/* Set string iterator to start of string                         */</span>
            ihLineIterator = ihLine.begin();
        
            <span class="comment">/* Check that we have a &#39;:&#39; record mark at the beginning          */</span>
            <span class="keywordflow">if</span> (*ihLineIterator != <span class="charliteral">&#39;:&#39;</span>)
            {
                <span class="comment">/* Add some warning code here                                 */</span>
                <span class="keywordtype">string</span> message;

                message = <span class="stringliteral">&quot;Line without record mark &#39;:&#39; found @ line &quot;</span> +
                                                ihLocal.ulToString(lineCounter);

                ihLocal.addWarning(message);
            }
        
            <span class="comment">/* Remove the record mark from the string as we don&#39;t need it     */</span>
            <span class="comment">/* anymore                                                        */</span>
            ihLine.erase(ihLineIterator);
        
            <span class="comment">/* Run through the whole line to check the checksum               */</span>
            <span class="keywordflow">for</span> (ihLineIterator = ihLine.begin(); 
                 ihLineIterator != ihLine.end(); 
                 <span class="comment">/* Nothing - really! */</span> )
            {
                <span class="comment">/* Convert the line in pair of chars (making a single byte)   */</span>
                <span class="comment">/* into single bytes, and then add to the checksum variable.  */</span>
                <span class="comment">/* By adding all the bytes in a line together *including* the */</span>
                <span class="comment">/* checksum byte, we should get a result of &#39;0&#39; at the end.   */</span>
                <span class="comment">/* If not, there is a checksum error                          */</span>
                ihByte.erase();
                
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                <span class="comment">/* Just in case there are an odd number of chars in the       */</span>
                <span class="comment">/* just check we didn&#39;t reach the end of the string early     */</span>
                <span class="keywordflow">if</span> (ihLineIterator != ihLine.end())
                {
                    ihByte += *ihLineIterator;
                    ++ihLineIterator;
                
                    byteRead = ihLocal.stringToHex(ihByte);
                           
                    intelHexChecksum += byteRead;
                }
                <span class="keywordflow">else</span>
                {
                    <span class="keywordtype">string</span> message;
                            
                    message = <span class="stringliteral">&quot;Odd number of characters in line &quot;</span> +
                                                ihLocal.ulToString(lineCounter);
                            
                    ihLocal.addError(message);
                }
            }
        
            <span class="comment">/* Make sure the checksum was ok                                  */</span>
            <span class="keywordflow">if</span> (intelHexChecksum == 0)
            {
                <span class="comment">/* Reset iterator back to beginning of the line so we can now */</span>
                <span class="comment">/* decode it                                                  */</span>
                ihLineIterator = ihLine.begin();
                
                <span class="comment">/* Clear all the variables associated with decoding a line of */</span>
                <span class="comment">/* Intel HEX code.                                            */</span>
                recordLength = 0;
                loadOffset = 0;
                
                <span class="comment">/* Get the record length                                      */</span>
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                recordLength = ihLocal.stringToHex(ihByte);
                
                <span class="comment">/* Get the load offset (2 bytes)                              */</span>
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                loadOffset = 
                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(ihLocal.stringToHex(ihByte));
                loadOffset &lt;&lt;= 8;
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                loadOffset += 
                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(ihLocal.stringToHex(ihByte));
                
                <span class="comment">/* Get the record type                                        */</span>
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                recordType = 
                   <span class="keyword">static_cast&lt;</span>intelhexRecordType<span class="keyword">&gt;</span>(ihLocal.stringToHex(ihByte));
                           
                <span class="comment">/* Decode the INFO or DATA portion of the record              */</span>
                <span class="keywordflow">switch</span> (recordType)
                {
                    <span class="keywordflow">case</span> DATA_RECORD:
                        ihLocal.decodeDataRecord(recordLength, loadOffset,
                                                 ihLineIterator);
                        <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
                        {
                            cout &lt;&lt; <span class="stringliteral">&quot;Data Record begining @ 0x&quot;</span> &lt;&lt; 
                                      ihLocal.ulToHexString(loadOffset) &lt;&lt; endl;
                        }
                        <span class="keywordflow">break</span>;
                    
                    <span class="keywordflow">case</span> END_OF_FILE_RECORD:
                        <span class="comment">/* Note the line number at this point. Later, check   */</span>
                        <span class="comment">/* that there were no more lines after this one.      */</span>
                        <span class="comment">/* Generate error if there were                       */</span>
                        <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
                        {
                            cout &lt;&lt; <span class="stringliteral">&quot;End of File&quot;</span> &lt;&lt; endl;
                        }
                        <span class="keywordflow">break</span>;
                        
                    <span class="keywordflow">case</span> EXTENDED_SEGMENT_ADDRESS:
                        <span class="comment">/* Make sure we have 2 bytes of data                  */</span>
                        <span class="keywordflow">if</span> (recordLength == 2)
                        {
                            <span class="comment">/* Extract the two bytes of the ESA               */</span>
                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> extSegAddress = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extSegAddress = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            extSegAddress &lt;&lt;= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extSegAddress += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            
                            <span class="comment">/* ESA is bits 4-19 of the segment base address   */</span>
                            <span class="comment">/* (SBA), so shift left 4 bits                    */</span>
                            extSegAddress &lt;&lt;= 4;
                            
                            <span class="comment">/* Update the SBA                                 */</span>
                            ihLocal.segmentBaseAddress = extSegAddress;
                        }
                        <span class="keywordflow">else</span>
                        {
                            <span class="comment">/* Note the error                                 */</span>
                            <span class="keywordtype">string</span> message;
                            
                            message = <span class="stringliteral">&quot;Extended Segment Address @ line &quot;</span> +
                                      ihLocal.ulToString(lineCounter) + 
                                      <span class="stringliteral">&quot; not 2 bytes as required.&quot;</span>;
                            
                            ihLocal.addError(message);
                        }
                        <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
                        {
                            cout &lt;&lt; <span class="stringliteral">&quot;Ext. Seg. Address found: 0x&quot;</span> &lt;&lt;
                               ihLocal.ulToHexString(ihLocal.segmentBaseAddress)
                                                                        &lt;&lt; endl;
                        }
                        
                        <span class="keywordflow">break</span>;
                        
                    <span class="keywordflow">case</span> START_SEGMENT_ADDRESS:
                        <span class="comment">/* Make sure we have 4 bytes of data                  */</span>
                        <span class="keywordflow">if</span> (recordLength == 4)
                        {
                            ihLocal.csRegister = 0;
                            ihLocal.ipRegister = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.csRegister = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.csRegister &lt;&lt;= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.csRegister += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                                
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.ipRegister = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.ipRegister &lt;&lt;= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.ipRegister += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                        }
                        <span class="keywordflow">else</span>
                        {
                            <span class="comment">/* Note the error                                 */</span>
                            <span class="comment">//cout &lt;&lt; &quot;Error in Start Seg. Address&quot; &lt;&lt; endl;</span>
                            
                            <span class="keywordtype">string</span> message;
                            
                            message = <span class="stringliteral">&quot;Start Segment Address @ line &quot;</span> +
                                      ihLocal.ulToString(lineCounter) + 
                                      <span class="stringliteral">&quot; not 4 bytes as required.&quot;</span>;
                            
                            ihLocal.addError(message);
                        }
                        <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
                        {
                            cout &lt;&lt; <span class="stringliteral">&quot;Start Seg. Address - CS 0x&quot;</span> &lt;&lt;
                                 ihLocal.ulToHexString(ihLocal.csRegister) &lt;&lt;
                                 <span class="stringliteral">&quot; IP 0x&quot;</span> &lt;&lt; 
                                 ihLocal.ulToHexString(ihLocal.ipRegister) 
                                                                        &lt;&lt; endl;
                        }
                        <span class="keywordflow">break</span>;
                        
                    <span class="keywordflow">case</span> EXTENDED_LINEAR_ADDRESS:
                        <span class="comment">/* Make sure we have 2 bytes of data                  */</span>
                        <span class="keywordflow">if</span> (recordLength == 2)
                        {
                            <span class="comment">/* Extract the two bytes of the ELA               */</span>
                            <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> extLinAddress = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extLinAddress = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            extLinAddress &lt;&lt;= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extLinAddress += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            
                            <span class="comment">/* ELA is bits 16-31 of the segment base address  */</span>
                            <span class="comment">/* (SBA), so shift left 16 bits                   */</span>
                            extLinAddress &lt;&lt;= 16;
                            
                            <span class="comment">/* Update the SBA                                 */</span>
                            ihLocal.segmentBaseAddress = extLinAddress;
                        }
                        <span class="keywordflow">else</span>
                        {
                            <span class="comment">/* Note the error                                 */</span>
                            <span class="comment">//cout &lt;&lt; &quot;Error in Ext. Lin. Address&quot; &lt;&lt; endl;</span>
                            
                            <span class="keywordtype">string</span> message;
                            
                            message = <span class="stringliteral">&quot;Extended Linear Address @ line &quot;</span> +
                                      ihLocal.ulToString(lineCounter) + 
                                      <span class="stringliteral">&quot; not 2 bytes as required.&quot;</span>;
                            
                            ihLocal.addError(message);
                        }
                        <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
                        {
                            cout &lt;&lt; <span class="stringliteral">&quot;Ext. Lin. Address 0x&quot;</span> &lt;&lt; 
                               ihLocal.ulToHexString(ihLocal.segmentBaseAddress)
                                                                        &lt;&lt; endl;
                        }
                        
                        <span class="keywordflow">break</span>;
                        
                    <span class="keywordflow">case</span> START_LINEAR_ADDRESS:
                        <span class="comment">/* Make sure we have 4 bytes of data                  */</span>
                        <span class="keywordflow">if</span> (recordLength == 4)
                        {
                            <span class="comment">/* Extract the four bytes of the SLA              */</span>
                            ihLocal.eipRegister = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.eipRegister &lt;&lt;= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.eipRegister &lt;&lt;= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.eipRegister &lt;&lt;= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>
                                                  (ihLocal.stringToHex(ihByte));
                        }
                        <span class="keywordflow">else</span>
                        {
                            <span class="comment">/* Note the error                                 */</span>
                            <span class="comment">//cout &lt;&lt; &quot;Error in Start Lin. Address&quot; &lt;&lt; endl;</span>
                            
                            <span class="keywordtype">string</span> message;
                            
                            message = <span class="stringliteral">&quot;Start Linear Address @ line &quot;</span> +
                                      ihLocal.ulToString(lineCounter) + 
                                      <span class="stringliteral">&quot; not 4 bytes as required.&quot;</span>;
                            
                            ihLocal.addError(message);
                        }
                        <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
                        {
                            cout &lt;&lt; <span class="stringliteral">&quot;Start Lin. Address - EIP 0x&quot;</span> &lt;&lt;
                                 ihLocal.ulToHexString(ihLocal.eipRegister) 
                                                                        &lt;&lt; endl;
                        }
                        <span class="keywordflow">break</span>;
                    
                    <span class="keywordflow">default</span>:
                        <span class="comment">/* Handle the error here                              */</span>
                        <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
                        {
                            cout &lt;&lt; <span class="stringliteral">&quot;Unknown Record @ line &quot;</span> &lt;&lt; 
                                        ihLocal.ulToString(lineCounter) &lt;&lt; endl;
                        }
                        
                        
                        <span class="keywordtype">string</span> message;
                            
                        message = <span class="stringliteral">&quot;Unknown Intel HEX record @ line &quot;</span> +
                                  ihLocal.ulToString(lineCounter);
                        
                        ihLocal.addError(message);
                        
                        <span class="keywordflow">break</span>;
                }
            }
            <span class="keywordflow">else</span>
            {
                <span class="comment">/* Note that the checksum contained an error                  */</span>
                <span class="keywordtype">string</span> message;
                            
                message = <span class="stringliteral">&quot;Checksum error @ line &quot;</span> + 
                          ihLocal.ulToString(lineCounter) + 
                          <span class="stringliteral">&quot;; calculated 0x&quot;</span> + 
                          ihLocal.ucToHexString(intelHexChecksum - byteRead) +
                          <span class="stringliteral">&quot; expected 0x&quot;</span> + 
                          ihLocal.ucToHexString(byteRead);
                
                ihLocal.addError(message);
            }
        }
    } <span class="keywordflow">while</span> (ihLine.length() &gt; 0);
    
    <span class="keywordflow">if</span> (ihLocal.verbose == <span class="keyword">true</span>)
    {
        cout &lt;&lt; <span class="stringliteral">&quot;File contained &quot;</span> &lt;&lt; lineCounter &lt;&lt; <span class="stringliteral">&quot; lines.&quot;</span> &lt;&lt; endl;
    }
    
    <span class="keywordflow">return</span>(dataIn);
}
</pre></div></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="intelhexclass_8hpp_source.html">intelhexclass.hpp</a></li>
<li><a class="el" href="intelhexclass_8cpp_source.html">intelhexclass.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Jan 9 2012 09:36:42 for Intel Hex Encoder/Decoder Class by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
