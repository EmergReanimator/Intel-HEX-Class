{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment Intel Hex Encoder/Decoder Class }Intel Hex Encoder/Decoder Class}
{\comment Generated byDoxgyen. }
{\creatim \yr2012\mo1\dy9\hr9\min36\sec42}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAB" }{}}{\fldrslt {\cs37\ul\cf2 intelhex}}}
 ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to decode, encode and manipulate Intel HEX format files })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b intelhexclass.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAA" }{}}{\fldrslt {\cs37\ul\cf2 intelhexclass.hpp}}}
 } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
intelhex Class Reference\par \pard\plain 
{\tc\tcl2 \v intelhex}
{\xe \v intelhex}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to decode, encode and manipulate Intel HEX format files. }}\par
{
{\f2 #include <intelhexclass.hpp>}}\par
Collaboration diagram for intelhex:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classintelhex__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b begin} (){\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b end} (){\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b jumpTo} (unsigned long address){\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b currentAddress} (){\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b startAddress} (){\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b endAddress} (){\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned char {\b getData} (){\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b insertData} (unsigned char data){\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b blankFill} (unsigned char data){\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b blankFill} (unsigned char *const data, unsigned long sizeOfData){\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b blankFill} (unsigned char *const data, unsigned long sizeOfData, unsigned long endAddress){\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b blankFillRandom} (){\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b blankFillRandom} (unsigned long endAddress){\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b blankFillAddressLowByte} (){\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b blankFillAddressLowByte} (unsigned long endAddress){\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b verboseOn} (){\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b verboseOff} (){\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

list< string > {\b ihWarnings}{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b noOfWarnings}{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

list< string > {\b ihErrors}{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b noOfErrors}{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ostream & {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAY" }{}}{\fldrslt {\cs37\ul\cf2 operator<<}}}
 (ostream &dataOut, const {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAB" }{}}{\fldrslt {\cs37\ul\cf2 intelhex}}}
 &ihLocal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
istream & {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAZ" }{}}{\fldrslt {\cs37\ul\cf2 operator>>}}}
 (istream &dataIn, {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAB" }{}}{\fldrslt {\cs37\ul\cf2 intelhex}}}
 &ihLocal)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to decode, encode and manipulate Intel HEX format files. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Intel HEX class allows the user to stream in the content of an Intel HEX file so that its content can by analysed more easily than trying to decode the Intel HEX file in a text editor. In conjunction with a suitable application it is possible to create content, analyse content and even compare the content of files with one another. \par
}{
Definition at line 83 of file intelhexclass.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator<<\:intelhex}
{\xe \v intelhex\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ostream& operator<< (ostream & {\i dataOut}, const {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAB" }{}}{\fldrslt {\cs37\ul\cf2 intelhex}}}
 & {\i ihLocal}){\f2  [friend]}}
}\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output stream overload operator Operator overloaded to encode any data held in memory into the Intel HEX format for storage on disk\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAZ" }{}}{\fldrslt {\cs37\ul\cf2 operator>>()}}}\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dataOut} - Output stream for to store the decoded file information \par
{\i ihLocal} - Points to this class so that friend function has access to private class members \par
}
}}
{\xe \v operator>>\:intelhex}
{\xe \v intelhex\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
istream& operator>> (istream & {\i dataIn}, {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAB" }{}}{\fldrslt {\cs37\ul\cf2 intelhex}}}
 & {\i ihLocal}){\f2  [friend]}}
}\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input stream overload operator Operator overloaded to decode data streamed in from a file in the Intel HEX format into memory\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAY" }{}}{\fldrslt {\cs37\ul\cf2 operator<<()}}}\par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i dataIn} - Input stream for the encoded file information \par
{\i ihLocal} - Points to this class so that friend function has access to private class members \par
}
}{
Definition at line 211 of file intelhexclass.cpp.}\par
{
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
    // Create a string to store lines of Intel Hex info\par
    string ihLine;\par
    /* Create a string to store a single byte of Intel HEX info               */\par
    string ihByte;\par
    // Create an iterator for this variable\par
    string::iterator ihLineIterator;\par
    // Create a line counter\par
    unsigned long lineCounter = 0;\par
    // Variable to hold a single byte (two chars) of data\par
    unsigned char byteRead;\par
    // Variable to calculate the checksum for each line\par
    unsigned char intelHexChecksum;\par
    // Variable to hold the record length\par
    unsigned char recordLength;\par
    // Variable to hold the load offset\par
    unsigned long loadOffset;\par
    // Variables to hold the record type\par
    intelhexRecordType recordType;\par
    \par
    do\par
    \{\par
        /* Clear the string before this next round                            */\par
        ihLine.erase();\par
        \par
        /* Clear the checksum before processing this line                     */\par
        intelHexChecksum = 0;\par
        \par
        /* Get a line of data                                                 */\par
        dataIn >> ihLine;\par
        \par
        /* If the line contained some data, process it                        */\par
        if (ihLine.length() > 0)\par
        \{\par
            /* Increment line counter                                         */\par
            lineCounter++;\par
        \par
            /* Set string iterator to start of string                         */\par
            ihLineIterator = ihLine.begin();\par
        \par
            /* Check that we have a ':' record mark at the beginning          */\par
            if (*ihLineIterator != ':')\par
            \{\par
                /* Add some warning code here                                 */\par
                string message;\par
\par
                message = "Line without record mark ':' found @ line " +\par
                                                ihLocal.ulToString(lineCounter);\par
\par
                ihLocal.addWarning(message);\par
            \}\par
        \par
            /* Remove the record mark from the string as we don't need it     */\par
            /* anymore                                                        */\par
            ihLine.erase(ihLineIterator);\par
        \par
            /* Run through the whole line to check the checksum               */\par
            for (ihLineIterator = ihLine.begin(); \par
                 ihLineIterator != ihLine.end(); \par
                 /* Nothing - really! */ )\par
            \{\par
                /* Convert the line in pair of chars (making a single byte)   */\par
                /* into single bytes, and then add to the checksum variable.  */\par
                /* By adding all the bytes in a line together *including* the */\par
                /* checksum byte, we should get a result of '0' at the end.   */\par
                /* If not, there is a checksum error                          */\par
                ihByte.erase();\par
                \par
                ihByte = *ihLineIterator;\par
                ++ihLineIterator;\par
                /* Just in case there are an odd number of chars in the       */\par
                /* just check we didn't reach the end of the string early     */\par
                if (ihLineIterator != ihLine.end())\par
                \{\par
                    ihByte += *ihLineIterator;\par
                    ++ihLineIterator;\par
                \par
                    byteRead = ihLocal.stringToHex(ihByte);\par
                           \par
                    intelHexChecksum += byteRead;\par
                \}\par
                else\par
                \{\par
                    string message;\par
                            \par
                    message = "Odd number of characters in line " +\par
                                                ihLocal.ulToString(lineCounter);\par
                            \par
                    ihLocal.addError(message);\par
                \}\par
            \}\par
        \par
            /* Make sure the checksum was ok                                  */\par
            if (intelHexChecksum == 0)\par
            \{\par
                /* Reset iterator back to beginning of the line so we can now */\par
                /* decode it                                                  */\par
                ihLineIterator = ihLine.begin();\par
                \par
                /* Clear all the variables associated with decoding a line of */\par
                /* Intel HEX code.                                            */\par
                recordLength = 0;\par
                loadOffset = 0;\par
                \par
                /* Get the record length                                      */\par
                ihByte.erase();\par
                ihByte = *ihLineIterator;\par
                ++ihLineIterator;\par
                ihByte += *ihLineIterator;\par
                ++ihLineIterator;\par
                recordLength = ihLocal.stringToHex(ihByte);\par
                \par
                /* Get the load offset (2 bytes)                              */\par
                ihByte.erase();\par
                ihByte = *ihLineIterator;\par
                ++ihLineIterator;\par
                ihByte += *ihLineIterator;\par
                ++ihLineIterator;\par
                loadOffset = \par
                        static_cast<unsigned long>(ihLocal.stringToHex(ihByte));\par
                loadOffset <<= 8;\par
                ihByte.erase();\par
                ihByte = *ihLineIterator;\par
                ++ihLineIterator;\par
                ihByte += *ihLineIterator;\par
                ++ihLineIterator;\par
                loadOffset += \par
                        static_cast<unsigned long>(ihLocal.stringToHex(ihByte));\par
                \par
                /* Get the record type                                        */\par
                ihByte.erase();\par
                ihByte = *ihLineIterator;\par
                ++ihLineIterator;\par
                ihByte += *ihLineIterator;\par
                ++ihLineIterator;\par
                recordType = \par
                   static_cast<intelhexRecordType>(ihLocal.stringToHex(ihByte));\par
                           \par
                /* Decode the INFO or DATA portion of the record              */\par
                switch (recordType)\par
                \{\par
                    case DATA_RECORD:\par
                        ihLocal.decodeDataRecord(recordLength, loadOffset,\par
                                                 ihLineIterator);\par
                        if (ihLocal.verbose == true)\par
                        \{\par
                            cout << "Data Record begining @ 0x" << \par
                                      ihLocal.ulToHexString(loadOffset) << endl;\par
                        \}\par
                        break;\par
                    \par
                    case END_OF_FILE_RECORD:\par
                        /* Note the line number at this point. Later, check   */\par
                        /* that there were no more lines after this one.      */\par
                        /* Generate error if there were                       */\par
                        if (ihLocal.verbose == true)\par
                        \{\par
                            cout << "End of File" << endl;\par
                        \}\par
                        break;\par
                        \par
                    case EXTENDED_SEGMENT_ADDRESS:\par
                        /* Make sure we have 2 bytes of data                  */\par
                        if (recordLength == 2)\par
                        \{\par
                            /* Extract the two bytes of the ESA               */\par
                            unsigned long extSegAddress = 0;\par
                            \par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            extSegAddress = static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            extSegAddress <<= 8;\par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            extSegAddress += static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            \par
                            /* ESA is bits 4-19 of the segment base address   */\par
                            /* (SBA), so shift left 4 bits                    */\par
                            extSegAddress <<= 4;\par
                            \par
                            /* Update the SBA                                 */\par
                            ihLocal.segmentBaseAddress = extSegAddress;\par
                        \}\par
                        else\par
                        \{\par
                            /* Note the error                                 */\par
                            string message;\par
                            \par
                            message = "Extended Segment Address @ line " +\par
                                      ihLocal.ulToString(lineCounter) + \par
                                      " not 2 bytes as required.";\par
                            \par
                            ihLocal.addError(message);\par
                        \}\par
                        if (ihLocal.verbose == true)\par
                        \{\par
                            cout << "Ext. Seg. Address found: 0x" <<\par
                               ihLocal.ulToHexString(ihLocal.segmentBaseAddress)\par
                                                                        << endl;\par
                        \}\par
                        \par
                        break;\par
                        \par
                    case START_SEGMENT_ADDRESS:\par
                        /* Make sure we have 4 bytes of data                  */\par
                        if (recordLength == 4)\par
                        \{\par
                            ihLocal.csRegister = 0;\par
                            ihLocal.ipRegister = 0;\par
                            \par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.csRegister = static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            ihLocal.csRegister <<= 8;\par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.csRegister += static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                                \par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.ipRegister = static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            ihLocal.ipRegister <<= 8;\par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.ipRegister += static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                        \}\par
                        else\par
                        \{\par
                            /* Note the error                                 */\par
                            //cout << "Error in Start Seg. Address" << endl;\par
                            \par
                            string message;\par
                            \par
                            message = "Start Segment Address @ line " +\par
                                      ihLocal.ulToString(lineCounter) + \par
                                      " not 4 bytes as required.";\par
                            \par
                            ihLocal.addError(message);\par
                        \}\par
                        if (ihLocal.verbose == true)\par
                        \{\par
                            cout << "Start Seg. Address - CS 0x" <<\par
                                 ihLocal.ulToHexString(ihLocal.csRegister) <<\par
                                 " IP 0x" << \par
                                 ihLocal.ulToHexString(ihLocal.ipRegister) \par
                                                                        << endl;\par
                        \}\par
                        break;\par
                        \par
                    case EXTENDED_LINEAR_ADDRESS:\par
                        /* Make sure we have 2 bytes of data                  */\par
                        if (recordLength == 2)\par
                        \{\par
                            /* Extract the two bytes of the ELA               */\par
                            unsigned long extLinAddress = 0;\par
                            \par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            extLinAddress = static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            extLinAddress <<= 8;\par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            extLinAddress += static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            \par
                            /* ELA is bits 16-31 of the segment base address  */\par
                            /* (SBA), so shift left 16 bits                   */\par
                            extLinAddress <<= 16;\par
                            \par
                            /* Update the SBA                                 */\par
                            ihLocal.segmentBaseAddress = extLinAddress;\par
                        \}\par
                        else\par
                        \{\par
                            /* Note the error                                 */\par
                            //cout << "Error in Ext. Lin. Address" << endl;\par
                            \par
                            string message;\par
                            \par
                            message = "Extended Linear Address @ line " +\par
                                      ihLocal.ulToString(lineCounter) + \par
                                      " not 2 bytes as required.";\par
                            \par
                            ihLocal.addError(message);\par
                        \}\par
                        if (ihLocal.verbose == true)\par
                        \{\par
                            cout << "Ext. Lin. Address 0x" << \par
                               ihLocal.ulToHexString(ihLocal.segmentBaseAddress)\par
                                                                        << endl;\par
                        \}\par
                        \par
                        break;\par
                        \par
                    case START_LINEAR_ADDRESS:\par
                        /* Make sure we have 4 bytes of data                  */\par
                        if (recordLength == 4)\par
                        \{\par
                            /* Extract the four bytes of the SLA              */\par
                            ihLocal.eipRegister = 0;\par
                            \par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.eipRegister = static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            ihLocal.eipRegister <<= 8;\par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.eipRegister += static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            ihLocal.eipRegister <<= 8;\par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.eipRegister += static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                            ihLocal.eipRegister <<= 8;\par
                            ihByte.erase();\par
                            ihByte = *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihByte += *ihLineIterator;\par
                            ++ihLineIterator;\par
                            ihLocal.eipRegister += static_cast<unsigned long>\par
                                                  (ihLocal.stringToHex(ihByte));\par
                        \}\par
                        else\par
                        \{\par
                            /* Note the error                                 */\par
                            //cout << "Error in Start Lin. Address" << endl;\par
                            \par
                            string message;\par
                            \par
                            message = "Start Linear Address @ line " +\par
                                      ihLocal.ulToString(lineCounter) + \par
                                      " not 4 bytes as required.";\par
                            \par
                            ihLocal.addError(message);\par
                        \}\par
                        if (ihLocal.verbose == true)\par
                        \{\par
                            cout << "Start Lin. Address - EIP 0x" <<\par
                                 ihLocal.ulToHexString(ihLocal.eipRegister) \par
                                                                        << endl;\par
                        \}\par
                        break;\par
                    \par
                    default:\par
                        /* Handle the error here                              */\par
                        if (ihLocal.verbose == true)\par
                        \{\par
                            cout << "Unknown Record @ line " << \par
                                        ihLocal.ulToString(lineCounter) << endl;\par
                        \}\par
                        \par
                        \par
                        string message;\par
                            \par
                        message = "Unknown Intel HEX record @ line " +\par
                                  ihLocal.ulToString(lineCounter);\par
                        \par
                        ihLocal.addError(message);\par
                        \par
                        break;\par
                \}\par
            \}\par
            else\par
            \{\par
                /* Note that the checksum contained an error                  */\par
                string message;\par
                            \par
                message = "Checksum error @ line " + \par
                          ihLocal.ulToString(lineCounter) + \par
                          "; calculated 0x" + \par
                          ihLocal.ucToHexString(intelHexChecksum - byteRead) +\par
                          " expected 0x" + \par
                          ihLocal.ucToHexString(byteRead);\par
                \par
                ihLocal.addError(message);\par
            \}\par
        \}\par
    \} while (ihLine.length() > 0);\par
    \par
    if (ihLocal.verbose == true)\par
    \{\par
        cout << "File contained " << lineCounter << " lines." << endl;\par
    \}\par
    \par
    return(dataIn);\par
\}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAA" }{}}{\fldrslt {\cs37\ul\cf2 intelhexclass.hpp}}}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
intelhexclass.cpp\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
intelhexclass.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v intelhexclass.hpp}
{\xe \v intelhexclass.hpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <map>}\par
{\f2 #include <list>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for intelhexclass.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "intelhexclass_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "intelhexclass_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAB" }{}}{\fldrslt {\cs37\ul\cf2 intelhex}}}
\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to decode, encode and manipulate Intel HEX format files. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Stuart Cording aka CODINGHEAD\par
}A class to handle the encoding, decoding and manipulatio of an Intel HEX format file as generated by many tool chains for embedded processors and microcontrollers.\par
This class is constructed based upon the definition given in the document 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988, \'A9 1998 Intel Corporation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid See the git versioning notes for version information \par
}}{
Definition in file {\field {\*\fldinst { HYPERLINK  \\l "AAAAAAAAAC" }{}}{\fldrslt {\cs37\ul\cf2 intelhexclass.hpp}}}
.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}