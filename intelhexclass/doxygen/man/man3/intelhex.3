.TH "intelhex" 3 "Mon Jan 9 2012" "Intel Hex Encoder/Decoder Class" \" -*- nroff -*-
.ad l
.nh
.SH NAME
intelhex \- 
.PP
Class to decode, encode and manipulate Intel HEX format files.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <intelhexclass.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBbegin\fP ()"
.br
.ti -1c
.RI "void \fBend\fP ()"
.br
.ti -1c
.RI "bool \fBjumpTo\fP (unsigned long address)"
.br
.ti -1c
.RI "unsigned long \fBcurrentAddress\fP ()"
.br
.ti -1c
.RI "unsigned long \fBstartAddress\fP ()"
.br
.ti -1c
.RI "unsigned long \fBendAddress\fP ()"
.br
.ti -1c
.RI "unsigned char \fBgetData\fP ()"
.br
.ti -1c
.RI "bool \fBinsertData\fP (unsigned char data)"
.br
.ti -1c
.RI "bool \fBblankFill\fP (unsigned char data)"
.br
.ti -1c
.RI "bool \fBblankFill\fP (unsigned char *const data, unsigned long sizeOfData)"
.br
.ti -1c
.RI "void \fBblankFill\fP (unsigned char *const data, unsigned long sizeOfData, unsigned long endAddress)"
.br
.ti -1c
.RI "bool \fBblankFillRandom\fP ()"
.br
.ti -1c
.RI "void \fBblankFillRandom\fP (unsigned long endAddress)"
.br
.ti -1c
.RI "bool \fBblankFillAddressLowByte\fP ()"
.br
.ti -1c
.RI "void \fBblankFillAddressLowByte\fP (unsigned long endAddress)"
.br
.ti -1c
.RI "void \fBverboseOn\fP ()"
.br
.ti -1c
.RI "void \fBverboseOff\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "list< string > \fBihWarnings\fP"
.br
.ti -1c
.RI "unsigned long \fBnoOfWarnings\fP"
.br
.ti -1c
.RI "list< string > \fBihErrors\fP"
.br
.ti -1c
.RI "unsigned long \fBnoOfErrors\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "ostream & \fBoperator<<\fP (ostream &dataOut, const \fBintelhex\fP &ihLocal)"
.br
.ti -1c
.RI "istream & \fBoperator>>\fP (istream &dataIn, \fBintelhex\fP &ihLocal)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Class to decode, encode and manipulate Intel HEX format files. 

The Intel HEX class allows the user to stream in the content of an Intel HEX file so that its content can by analysed more easily than trying to decode the Intel HEX file in a text editor. In conjunction with a suitable application it is possible to create content, analyse content and even compare the content of files with one another. 
.PP
Definition at line 83 of file intelhexclass.hpp.
.SH "Friends And Related Function Documentation"
.PP 
.SS "ostream& operator<< (ostream & dataOut, const \fBintelhex\fP & ihLocal)\fC [friend]\fP"Output stream overload operator Operator overloaded to encode any data held in memory into the Intel HEX format for storage on disk
.PP
\fBSee also:\fP
.RS 4
\fBoperator>>()\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdataOut\fP - Output stream for to store the decoded file information 
.br
\fIihLocal\fP - Points to this class so that friend function has access to private class members 
.RE
.PP

.SS "istream& operator>> (istream & dataIn, \fBintelhex\fP & ihLocal)\fC [friend]\fP"Input stream overload operator Operator overloaded to decode data streamed in from a file in the Intel HEX format into memory
.PP
\fBSee also:\fP
.RS 4
\fBoperator<<()\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdataIn\fP - Input stream for the encoded file information 
.br
\fIihLocal\fP - Points to this class so that friend function has access to private class members 
.RE
.PP

.PP
Definition at line 211 of file intelhexclass.cpp.
.PP
.nf
{
    // Create a string to store lines of Intel Hex info
    string ihLine;
    /* Create a string to store a single byte of Intel HEX info               */
    string ihByte;
    // Create an iterator for this variable
    string::iterator ihLineIterator;
    // Create a line counter
    unsigned long lineCounter = 0;
    // Variable to hold a single byte (two chars) of data
    unsigned char byteRead;
    // Variable to calculate the checksum for each line
    unsigned char intelHexChecksum;
    // Variable to hold the record length
    unsigned char recordLength;
    // Variable to hold the load offset
    unsigned long loadOffset;
    // Variables to hold the record type
    intelhexRecordType recordType;
    
    do
    {
        /* Clear the string before this next round                            */
        ihLine.erase();
        
        /* Clear the checksum before processing this line                     */
        intelHexChecksum = 0;
        
        /* Get a line of data                                                 */
        dataIn >> ihLine;
        
        /* If the line contained some data, process it                        */
        if (ihLine.length() > 0)
        {
            /* Increment line counter                                         */
            lineCounter++;
        
            /* Set string iterator to start of string                         */
            ihLineIterator = ihLine.begin();
        
            /* Check that we have a ':' record mark at the beginning          */
            if (*ihLineIterator != ':')
            {
                /* Add some warning code here                                 */
                string message;

                message = 'Line without record mark ':' found @ line ' +
                                                ihLocal.ulToString(lineCounter);

                ihLocal.addWarning(message);
            }
        
            /* Remove the record mark from the string as we don't need it     */
            /* anymore                                                        */
            ihLine.erase(ihLineIterator);
        
            /* Run through the whole line to check the checksum               */
            for (ihLineIterator = ihLine.begin(); 
                 ihLineIterator != ihLine.end(); 
                 /* Nothing - really! */ )
            {
                /* Convert the line in pair of chars (making a single byte)   */
                /* into single bytes, and then add to the checksum variable.  */
                /* By adding all the bytes in a line together *including* the */
                /* checksum byte, we should get a result of '0' at the end.   */
                /* If not, there is a checksum error                          */
                ihByte.erase();
                
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                /* Just in case there are an odd number of chars in the       */
                /* just check we didn't reach the end of the string early     */
                if (ihLineIterator != ihLine.end())
                {
                    ihByte += *ihLineIterator;
                    ++ihLineIterator;
                
                    byteRead = ihLocal.stringToHex(ihByte);
                           
                    intelHexChecksum += byteRead;
                }
                else
                {
                    string message;
                            
                    message = 'Odd number of characters in line ' +
                                                ihLocal.ulToString(lineCounter);
                            
                    ihLocal.addError(message);
                }
            }
        
            /* Make sure the checksum was ok                                  */
            if (intelHexChecksum == 0)
            {
                /* Reset iterator back to beginning of the line so we can now */
                /* decode it                                                  */
                ihLineIterator = ihLine.begin();
                
                /* Clear all the variables associated with decoding a line of */
                /* Intel HEX code.                                            */
                recordLength = 0;
                loadOffset = 0;
                
                /* Get the record length                                      */
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                recordLength = ihLocal.stringToHex(ihByte);
                
                /* Get the load offset (2 bytes)                              */
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                loadOffset = 
                        static_cast<unsigned long>(ihLocal.stringToHex(ihByte));
                loadOffset <<= 8;
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                loadOffset += 
                        static_cast<unsigned long>(ihLocal.stringToHex(ihByte));
                
                /* Get the record type                                        */
                ihByte.erase();
                ihByte = *ihLineIterator;
                ++ihLineIterator;
                ihByte += *ihLineIterator;
                ++ihLineIterator;
                recordType = 
                   static_cast<intelhexRecordType>(ihLocal.stringToHex(ihByte));
                           
                /* Decode the INFO or DATA portion of the record              */
                switch (recordType)
                {
                    case DATA_RECORD:
                        ihLocal.decodeDataRecord(recordLength, loadOffset,
                                                 ihLineIterator);
                        if (ihLocal.verbose == true)
                        {
                            cout << 'Data Record begining @ 0x' << 
                                      ihLocal.ulToHexString(loadOffset) << endl;
                        }
                        break;
                    
                    case END_OF_FILE_RECORD:
                        /* Note the line number at this point. Later, check   */
                        /* that there were no more lines after this one.      */
                        /* Generate error if there were                       */
                        if (ihLocal.verbose == true)
                        {
                            cout << 'End of File' << endl;
                        }
                        break;
                        
                    case EXTENDED_SEGMENT_ADDRESS:
                        /* Make sure we have 2 bytes of data                  */
                        if (recordLength == 2)
                        {
                            /* Extract the two bytes of the ESA               */
                            unsigned long extSegAddress = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extSegAddress = static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            extSegAddress <<= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extSegAddress += static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            
                            /* ESA is bits 4-19 of the segment base address   */
                            /* (SBA), so shift left 4 bits                    */
                            extSegAddress <<= 4;
                            
                            /* Update the SBA                                 */
                            ihLocal.segmentBaseAddress = extSegAddress;
                        }
                        else
                        {
                            /* Note the error                                 */
                            string message;
                            
                            message = 'Extended Segment Address @ line ' +
                                      ihLocal.ulToString(lineCounter) + 
                                      ' not 2 bytes as required.';
                            
                            ihLocal.addError(message);
                        }
                        if (ihLocal.verbose == true)
                        {
                            cout << 'Ext. Seg. Address found: 0x' <<
                               ihLocal.ulToHexString(ihLocal.segmentBaseAddress)
                                                                        << endl;
                        }
                        
                        break;
                        
                    case START_SEGMENT_ADDRESS:
                        /* Make sure we have 4 bytes of data                  */
                        if (recordLength == 4)
                        {
                            ihLocal.csRegister = 0;
                            ihLocal.ipRegister = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.csRegister = static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.csRegister <<= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.csRegister += static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                                
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.ipRegister = static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.ipRegister <<= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.ipRegister += static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                        }
                        else
                        {
                            /* Note the error                                 */
                            //cout << 'Error in Start Seg. Address' << endl;
                            
                            string message;
                            
                            message = 'Start Segment Address @ line ' +
                                      ihLocal.ulToString(lineCounter) + 
                                      ' not 4 bytes as required.';
                            
                            ihLocal.addError(message);
                        }
                        if (ihLocal.verbose == true)
                        {
                            cout << 'Start Seg. Address - CS 0x' <<
                                 ihLocal.ulToHexString(ihLocal.csRegister) <<
                                 ' IP 0x' << 
                                 ihLocal.ulToHexString(ihLocal.ipRegister) 
                                                                        << endl;
                        }
                        break;
                        
                    case EXTENDED_LINEAR_ADDRESS:
                        /* Make sure we have 2 bytes of data                  */
                        if (recordLength == 2)
                        {
                            /* Extract the two bytes of the ELA               */
                            unsigned long extLinAddress = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extLinAddress = static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            extLinAddress <<= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            extLinAddress += static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            
                            /* ELA is bits 16-31 of the segment base address  */
                            /* (SBA), so shift left 16 bits                   */
                            extLinAddress <<= 16;
                            
                            /* Update the SBA                                 */
                            ihLocal.segmentBaseAddress = extLinAddress;
                        }
                        else
                        {
                            /* Note the error                                 */
                            //cout << 'Error in Ext. Lin. Address' << endl;
                            
                            string message;
                            
                            message = 'Extended Linear Address @ line ' +
                                      ihLocal.ulToString(lineCounter) + 
                                      ' not 2 bytes as required.';
                            
                            ihLocal.addError(message);
                        }
                        if (ihLocal.verbose == true)
                        {
                            cout << 'Ext. Lin. Address 0x' << 
                               ihLocal.ulToHexString(ihLocal.segmentBaseAddress)
                                                                        << endl;
                        }
                        
                        break;
                        
                    case START_LINEAR_ADDRESS:
                        /* Make sure we have 4 bytes of data                  */
                        if (recordLength == 4)
                        {
                            /* Extract the four bytes of the SLA              */
                            ihLocal.eipRegister = 0;
                            
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister = static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.eipRegister <<= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister += static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.eipRegister <<= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister += static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                            ihLocal.eipRegister <<= 8;
                            ihByte.erase();
                            ihByte = *ihLineIterator;
                            ++ihLineIterator;
                            ihByte += *ihLineIterator;
                            ++ihLineIterator;
                            ihLocal.eipRegister += static_cast<unsigned long>
                                                  (ihLocal.stringToHex(ihByte));
                        }
                        else
                        {
                            /* Note the error                                 */
                            //cout << 'Error in Start Lin. Address' << endl;
                            
                            string message;
                            
                            message = 'Start Linear Address @ line ' +
                                      ihLocal.ulToString(lineCounter) + 
                                      ' not 4 bytes as required.';
                            
                            ihLocal.addError(message);
                        }
                        if (ihLocal.verbose == true)
                        {
                            cout << 'Start Lin. Address - EIP 0x' <<
                                 ihLocal.ulToHexString(ihLocal.eipRegister) 
                                                                        << endl;
                        }
                        break;
                    
                    default:
                        /* Handle the error here                              */
                        if (ihLocal.verbose == true)
                        {
                            cout << 'Unknown Record @ line ' << 
                                        ihLocal.ulToString(lineCounter) << endl;
                        }
                        
                        
                        string message;
                            
                        message = 'Unknown Intel HEX record @ line ' +
                                  ihLocal.ulToString(lineCounter);
                        
                        ihLocal.addError(message);
                        
                        break;
                }
            }
            else
            {
                /* Note that the checksum contained an error                  */
                string message;
                            
                message = 'Checksum error @ line ' + 
                          ihLocal.ulToString(lineCounter) + 
                          '; calculated 0x' + 
                          ihLocal.ucToHexString(intelHexChecksum - byteRead) +
                          ' expected 0x' + 
                          ihLocal.ucToHexString(byteRead);
                
                ihLocal.addError(message);
            }
        }
    } while (ihLine.length() > 0);
    
    if (ihLocal.verbose == true)
    {
        cout << 'File contained ' << lineCounter << ' lines.' << endl;
    }
    
    return(dataIn);
}
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Intel Hex Encoder/Decoder Class from the source code.
