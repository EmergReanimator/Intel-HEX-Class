/*******************************************************************************
* intelhexclass - class definitions                                            *
*                                                                              *
* A class to handle the encoding and decoding of an Intel HEX format file as   *
* generated by many tool chains for embedded processors and microcontrollers.  *
*                                                                              *
* This class is constructed based upon the definition given in the document    *
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988, *
* © 1998 Intel Corporation                                                     *
*------------------------------------------------------------------------------*
* class intelhex                                                               *
*   Member Functions:                                                          *
*                                                                              *
*******************************************************************************/
/*******************************************************************************
*
* CIRCULAR BUFFER MODULE
*
*******************************************************************************/

/******************************************************************************/
/**
* \file intelhexclass.h
* \author Stuart Cording aka CODINGHEAD 
* 
* A class to handle the encoding, decoding and manipulatio of an Intel HEX
* format file as generated by many tool chains for embedded processors and 
* microcontrollers.
*
* This class is constructed based upon the definition given in the document
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988,
* © 1998 Intel Corporation.
********************************************************************************
* \note See the git versioning notes for version information
*
*******************************************************************************/

/*******************************************************************************
*
*                            INTEL HEX CLASS MODULE
*
*******************************************************************************/

#ifndef INTELHEXCLASS_MODULE_PRESENT__
#define INTELHEXCLASS_MODULE_PRESENT__

/*******************************************************************************
*                                 INCLUDE FILES
*******************************************************************************/
#include <iostream>
#include <map>
#include <list>

/*******************************************************************************
*                                    EXTERNS
*******************************************************************************/


/*******************************************************************************
*                             DEFAULT CONFIGURATION
*******************************************************************************/


/*******************************************************************************
*                                    DEFINES
*******************************************************************************/

using namespace std;

/******************************************************************************/
/** \cond
* class - intelhex
* \endcond
*
* \brief Class to decode, encode and manipulate Intel HEX format files.
*
* The Intel HEX class allows the user to stream in the content of an Intel HEX
* file so that its content can by analysed more easily than trying to decode
* the Intel HEX file in a text editor. In conjunction with a suitable 
* application it is possible to create content, analyse content and even compare
* the content of files with one another.
*******************************************************************************/
class intelhex {
        /**********************************************************************/
        /** Output stream overload operator.                                   
        * Operator overloaded to encode any data held in memory into the Intel
        * HEX format for storage on disk                 
        *
        * \sa operator>>()
        *
        * \param dataOut    - Output stream for to store the decoded file 
        *                     information
        * \param ihLocal    - Points to this class so that friend function has
        *                     access to private class members
        *
        * \retval           - pointer to output stream
        ***********************************************************************/
        friend ostream& operator<<(ostream& dataOut, 
                                   intelhex& ihLocal);
        
        /**********************************************************************/
        /** Input stream overload operator.                                   
        * Operator overloaded to decode data streamed in from a file in the 
        * Intel HEX format into memory                 
        *
        * \sa operator<<()
        *
        * \param dataIn     - Input stream for the encoded file information
        * \param ihLocal    - Points to this class so that friend function has
        *                     access to private class members
        *
        * \retval           - pointer to input stream
        ***********************************************************************/
        friend istream& operator>>(istream& dataIn, 
                                   intelhex& ihLocal);

    private:
        /**********************************************************************/
        /** Container for decoded Intel HEX content.                                 
        * STL map holding the addresses found in the Intel HEX file and the
        * associated data byte stored at that address                 
        ***********************************************************************/
        map<unsigned long, unsigned char> ihContent;
        
        /**********************************************************************/
        /** Iterator for the container holding the decoded Intel HEX content. 
        ***********************************************************************/
        map<unsigned long, unsigned char>::iterator ihIterator;
        
        /**********************************************************************/
        /** Pair for the container holding the decoded Intel HEX content. 
        * This is used to acquire the result of an attempt to insert new data
        * into ihContent. Since the ihContent is a map STL, it can't allow
        * data to be assigned to the same address more than once. In this way we
        * can ensure that no address in a file is falsely assigned data more 
        * than once.
        ***********************************************************************/
        pair<map<unsigned long, unsigned char>::iterator,bool> ihReturn;
  
        /**********************************************************************/
        /** Stores segment base address of Intel HEX file.
        * The segment base address is a 32-bit address to which the current
        * load offset (as found in a Data Record line of the Intel HEX file) is
        * added to calculate the actual address of the data. The Data Records
        * can only point to a 64kByte address, so the segment base address 
        * expands the addressing to 4GB. This variable always holds the last
        * address accessed.
        ***********************************************************************/
        unsigned long segmentBaseAddress;
        
        /**********************************************************************/
        /** Stores the content of the CS/IP Registers, if used.
        * Used to store the content of the CS and IS Register for HEX files 
        * created for x286 or earlier Intel processors. This information is 
        * retrieved from the Start Segment Address Record.
        * The found element defines if these registers hold valid data or not.
        *
        * \param    csRegister  - content of the CS register
        * \param    ipRegister  - content of the IP register
        * \param    exists      - defines if values for the above registers have
        *                         been written (true) or not (false)
        ***********************************************************************/
        struct {
            unsigned short  csRegister;
            unsigned short  ipRegister;
            bool            exists;
        } startSegmentAddress;
        
        /**********************************************************************/
        /** Stores the content of the EIP Register, if used.
        * Used to store the content of the EIP Register for HEX files created
        * for x386 Intel processors. This information is retrieved from the
        * the Start Linear Address Record.
        * The found element defines if this register holds valid data or not.
        *
        * \param    eipRegister - content of the EIP register
        * \param    exists      - defines if a value for the above register has
        *                         been written (true) or not (false)
        ***********************************************************************/
        struct {
            unsigned long   eipRegister;
            bool            exists;
        } startLinearAddress;
        
        
        /**********************************************************************/
        /** Structure to hold warning messages
        * Holds warning messages generated during encoding/decoding process and
        * number of messages currently present in system
        *
        * \param    ihWarnings      - list of warning messages as strings
        * \param    noOfWarnings    - no of warning messages still present in 
        *                             the list
        ***********************************************************************/
        struct {
            list<string> ihWarnings;
            unsigned long noOfWarnings;
        } msgWarning;
        
        /**********************************************************************/
        /** Structure to hold error messages
        * Holds error messages generated during encoding/decoding process and 
        * number of messages currently present in system
        *
        * \param    ihErrors        - list of error messages as strings
        * \param    noOferrors      - no of error messages still present in the
        *                             list
        ***********************************************************************/
        struct {
            list<string> ihErrors;
            unsigned long noOfErrors;
        } msgError;
        
        /**********************************************************************/
        /** Note that EOF record is found
        * Used to note that the EOF record was found in order to ensure that it
        * doesn't appear twice during encoding.                
        ***********************************************************************/
        bool foundEof;
        
        /**********************************************************************/
        /** Select verbose mode
        * Used during development to display messages as the incoming data 
        * stream is decoded                
        ***********************************************************************/
        bool verbose;

        /**********************************************************************/
        /** Select segment address mode
        * If true, use the segment addressing mode when encoding files.
        * otherwise the default linear address mode will be used. Please refer 
        * to Intel's Hexadecimal Object File Format Specifiation for further
        * information.
        ***********************************************************************/
        bool segmentAddressMode;

        /**********************************************************************/        
        /** Converts a 2 char string to its HEX value
        * Converts a two byte string to its equivalent value in hexadecimal
        *
        * \param        value   - a two character, valid ASCII representation of 
        *                         a hexadecimal value
        * 
        * \retval       'value' valid   - 8-bit value
        * \retval       'value' invalid - 0x00 and calls addWarning()
        *
        * \note
        * This function will post a warning message using the warning handling
        * system addWarning() if:
        *   -# The string contains anything other that exactly two characters
        *   -# The string contains anything other than the characters 0-9, a-f
        *      and A-F
        *
        * \sa
        * ulToHexString(), ucToHexString(), ulToString()
        ***********************************************************************/
        unsigned char stringToHex(string value);

        /**********************************************************************/        
        /** Converts an unsigned long to a string in HEX format               
        * Takes the received paramter and converts it into its equivalent value
        * represented in ASCII and formatted in hexadecimal. Return value is an
        * 8 character long string, prefaced with '0's where necessary.
        *
        * \param        value   - a value between 0x0000000 and 0xFFFFFFFF
        * 
        * \retval               - 8-character long string
        *
        * \note
        * Alpha characters are capitalised.
        *
        * \sa
        * stringToHex(), ucToHexString(), ulToString()
        ***********************************************************************/
        string ulToHexString(unsigned long value);

        /**********************************************************************/        
        /** Converts an unsigned char to a string in HEX format               
        * Takes the received paramter and converts it into its equivalent value
        * represented in ASCII and formatted in hexadecimal. Return value is a
        * 2 character long string, prefaced with '0' where necessary.
        *
        * \param        value   - a value between 0x00 and 0xFF
        * 
        * \retval               - 2-character long string
        *
        * \note
        * Alpha characters are capitalised.
        *
        * \sa
        * stringToHex(), ulToHexString(), ulToString()
        ***********************************************************************/
        string ucToHexString(unsigned char value);
        
        /**********************************************************************/
        /** Converts an unsigned long to a string in DEC format               
        * Takes the received paramter and converts it into its equivalent value
        * represented in ASCII and formatted in decimal. Return value will never
        * be longer than a 48 character long string.
        *
        * \param        value   - value to be converted
        * 
        * \retval               - ASCII string representation of value
        *
        * \sa
        * stringToHex(), ulToHexString(), ucToHexString()
        ***********************************************************************/
        string ulToString(unsigned long value);
        
        /**********************************************************************/
        /** Decodes the data content of a data record                         
        * Takes the data element of a data record in string format, converts
        * each 2 char element into a single byte and then inserts that byte of
        * data into the ihContent STL map.
        *
        * \sa encodeDataRecord()
        *
        * \param recordLength   - Number of bytes in this record as extracted
        *                         from this line in the Intel HEX file
        * \param loadOffset     - The offset from the segment base address for 
        *                         the first byte in this record
        * \param data           - The data content of the record in a string
        ***********************************************************************/
        void decodeDataRecord(unsigned char recordLength,
                              unsigned long loadOffset, 
                              string::const_iterator data);
                              
        /**********************************************************************/
        /** Add a warning message to the warning message list      
        *
        * \param    warningMessage - the text to be added for this warning
        ***********************************************************************/
        void addWarning(string warningMessage);
        
        /**********************************************************************/
        /** Add an error message to the error message list                
        *
        * \param    errorMessage - the text to be added for this error        
        ***********************************************************************/
        void addError(string errorMessage);
        
    public:
        /**********************************************************************/
        /** intelhex Class Constructor
        * Important initialisation steps performed here:
        * - clear segment base address to zero
        * - clear all x86 start address registers to zero
        * - note that there are, as yet, no errors or warnings
        * - note that the EOF record has not yet been found
        * - set verbode mode to 'false' (default)
        ***********************************************************************/
        intelhex()
        {
            /* Initialise the segment base address to zero                    */
            segmentBaseAddress = 0;
            /* Clear content of register variables used with the 'Start Segment'
            *  and 'Start Linear' address records                             */
            startSegmentAddress.ipRegister = 0;
            startSegmentAddress.csRegister = 0;
            startSegmentAddress.exists = false;
            startLinearAddress.eipRegister = 0;
            startLinearAddress.exists = false;
            /* Set up error and warning handling variables                    */
            msgWarning.noOfWarnings = 0;
            msgError.noOfErrors = 0;
            /* Note that the EOF record has not been found yet                */
            foundEof = false;
            /* Set verbose mode to off                                        */
            verbose = false;
            /* Set segment address mode to false (default)                    */
            segmentAddressMode = false;
        }

        /* Destructor                                                         */
        ~intelhex()
        {
            /* Currently nothing */
        }
        
        /**********************************************************************/
        /** Moves the address pointer to the first available address.
        * The address pointer will be moved to the first available address in 
        * memory of the decoded file or of the data the user has inserted into
        * memory for the purpose of encoding into the Intel HEX format.
        *
        * \sa end()
        *
        * \note This function has no effect if no file has been as yet decoded
        * and no data has been inserted into memory.
        ***********************************************************************/
        void begin()
        {
            if (ihContent.size() != 0)
            {
                map<unsigned long, unsigned char>::iterator it;
                it = ihContent.begin();
                segmentBaseAddress = (*it).first;
            }
        }
        
        /**********************************************************************/
        /** Moves the address pointer to the last available address.
        * The address pointer will be moved to the last available address in 
        * memory of the decoded file or of the data the user has inserted into
        * memory for the purpose of encoding into the Intel HEX format.
        *
        * \sa begin()
        *
        * \note This function has no effect if no file has been as yet decoded
        * and no data has been inserted into memory.
        ***********************************************************************/
        void end()
        {
            if (ihContent.size() != 0)
            {
                map<unsigned long, unsigned char>::reverse_iterator rit;
                rit = ihContent.rbegin();
                segmentBaseAddress = (*rit).first;
            }
        }
        
        /**********************************************************************/
        /** Moves the address pointer to the desired address.
        * Address pointer will take on the requested address.
        *
        * \sa currentAddress()
        *
        * \param address        - Desired new address for the address pointer
        ***********************************************************************/
        void jumpTo(unsigned long address)
        {
            segmentBaseAddress = address;
        }
        
        /**********************************************************************/
        /** Returns the current segment base address.
        * Current address will be returned.
        *
        * \sa jumpTo()
        *
        * \retval   Current address being pointed to.
        ***********************************************************************/
        unsigned long currentAddress()
        {
            return segmentBaseAddress;
        }
        
        /**********************************************************************/
        /** Returns the lowest address currently available.
        * Returns the first address that appears in the memory if there is data
        * present. If not, no value will be returned.
        *
        * \sa endAddress()
        *
        * \param address    - variable to hold address requested
        *
        * \retval true      - address existed and returned value is valid
        * \retval false     - address did not exist and returned valid is not
        *                     valid
        ***********************************************************************/
        bool startAddress(unsigned long * address)
        {
            if (ihContent.size() != 0)
            {
                map<unsigned long, unsigned char>::iterator it;
            
                it = ihContent.begin();
                *address = (*it).first;
                return true;
            }
            
            return false;
        }
        
        /**********************************************************************/
        /** Returns the highest address currently available.
        * Returns the last address that appears in the memory if there is data
        * present. If not, no value will be returned.
        *
        * \sa startAddress()
        *
        * \param address    - variable to hold address requested
        *
        * \retval true      - address existed and returned value is valid
        * \retval false     - address did not exist and returned valid is not
        *                     valid
        ***********************************************************************/
        bool endAddress(unsigned long * address)
        {
            if (ihContent.size() != 0)
            {
                map<unsigned long, unsigned char>::reverse_iterator rit;
            
                rit = ihContent.rbegin();
                *address = (*rit).first;
                return true;
            }
            
            return false;
        }

        bool getData(unsigned char * data);
        bool getData(unsigned char * data, unsigned long address);
        
        /**********************************************************************/
        /** Inserts desired byte at the current address pointer.
        * Inserts byte of data at the current address pointer
        *
        * \sa startAddress()
        *
        * \param    data - data byte to be inserted
        ***********************************************************************/
        bool insertData(unsigned char data);
        bool insertData(unsigned char data, unsigned long address);
        
        void overwriteData(unsigned char data);
        void overwriteData(unsigned char data, unsigned long address);
        
        bool blankFill(unsigned char data);
        
        bool blankFill(unsigned char * const data, unsigned long sizeOfData);
        
        void blankFill(unsigned char * const data, unsigned long sizeOfData,
                       unsigned long endAddress);
        
        bool blankFillRandom();
        
        void blankFillRandom(unsigned long endAddress);
        
        bool blankFillAddressLowByte();
        
        void blankFillAddressLowByte(unsigned long endAddress);
        
        /**********************************************************************/
        /** Returns number of unread warning messages
        * Number of unread warning messages will be returned.
        *
        * \sa popNextWarning(), getNoErrors(), popNextError()
        ***********************************************************************/
        unsigned long getNoWarnings()
        {
            return msgWarning.noOfWarnings;
        }
        
        /**********************************************************************/
        /** Returns number of unread error messages
        * Number of unread error messages will be returned.
        *
        * \sa popNextWarning(), getNoWarnings(), popNextError()
        ***********************************************************************/
        unsigned long getNoErrors()
        {
            return msgError.noOfErrors;
        }
        
        /**********************************************************************/
        /** Pop next warning message from the list of warnings.
        * Next warning message is returned from the list of warnings. If there 
        * are no more warning in the list, the string will be unchanged.
        *
        * \sa getNoWarnings(), getNoErrors(), popNextError()
        *
        * \param    warning - variable to store warning string to be returned
        *
        * \retval   true    - more warning messages are available
        * \retval   false   - no more warning messages are available
        ***********************************************************************/
        bool popNextWarning(string& warning)
        {
            if (msgWarning.noOfWarnings > 0)
            {
                warning = msgWarning.ihWarnings.front();
                
                msgWarning.ihWarnings.pop_front();
            
                msgWarning.noOfWarnings = msgWarning.ihWarnings.size();
                
                return true;
            }
            else
            {
                return false;
            }
        }
        
        /**********************************************************************/
        /** Pop next error message from the list of errors.
        * Next error message is returned from the list of errors. If there are
        * no more errors in the list, no string will be returned unchanged.
        *
        * \sa getNoWarnings(), getNoErrors(), popNextError()
        *
        * \param    error   - variable to store error string to be returned
        *
        * \retval   true    - more error messages are available
        * \retval   false   - no more error messages are available
        ***********************************************************************/
        bool popNextError(string& error)
        {
            if (msgError.noOfErrors > 0)
            {
                error = msgError.ihErrors.front();
                
                msgError.ihErrors.pop_front();
            
                msgError.noOfErrors = msgError.ihErrors.size();
                
                return true;
            }
            else
            {
                return false;
            }
        }
        
        /**********************************************************************/
        /** Returns segment start address for the IP and ES registers.
        * If these values exist, they will be returned. If not, the function
        * returns false.
        *
        * \sa getStartLinearAddress(), setStartSegmentAddress(), 
        *     setStartLinearAddress()
        *
        * \param    ipRegister  - variable to store IP register's value
        * \param    csRegister  - variable to store CS register's value
        *
        * \retval   true    - IP and CS registers have defined values
        * \retval   false   - IP and CS registers do not contain values
        ***********************************************************************/
        bool getStartSegmentAddress(unsigned short * ipRegister, 
                                    unsigned short * csRegister)
        {
            if (startSegmentAddress.exists == true)
            {
                *ipRegister = startSegmentAddress.ipRegister;
                *csRegister = startSegmentAddress.csRegister;
            }
            
            return startSegmentAddress.exists;
        }
        
        /**********************************************************************/
        /** Returns segment linear address for the EIP register.
        * If this value exists, they will be returned. If not, the function
        * returns false.
        *
        * \sa getStartSegmentAddress(), setStartSegmentAddress(), 
        *     setStartLinearAddress()
        *
        * \param    eipRegister - variable to store EIP register's value
        *
        * \retval   true    - EIP register has defined value
        * \retval   false   - EIP register do not contain value
        ***********************************************************************/
        bool getStartLinearAddress(unsigned long * eipRegister)
        {
            if (startLinearAddress.exists == true)
            {
                *eipRegister = startLinearAddress.eipRegister;
            }
            
            return startLinearAddress.exists;
        }
        
        /**********************************************************************/
        /** Sets the segment start address for the IP and CS registers.
        * Allows user to define or redefine the contents of the IP and CS 
        * registers
        *
        * \sa getStartLinearAddress(), getStartSegmentAddress(), 
        *     setStartLinearAddress()
        *
        * \param    ipRegister  - desired IP register value
        * \param    csRegister  - desired CS register value
        ***********************************************************************/
        void setStartSegmentAddress(unsigned short ipRegister, 
                                    unsigned short csRegister)
        {
            startSegmentAddress.ipRegister = ipRegister;
            startSegmentAddress.csRegister = csRegister;
            startSegmentAddress.exists = true;
        }
        
        /**********************************************************************/
        /** Sets the segment start address for the EIP register.
        * Allows user to define or redefine the contents of the EIP register
        *
        * \sa getStartSegmentAddress(), setStartSegmentAddress(), 
        *     getStartLinearAddress()
        *
        * \param    eipRegister - desired EIP register value
        ***********************************************************************/
        void setStartLinearAddress(unsigned long eipRegister)
        {
            startLinearAddress.eipRegister = eipRegister;
            startLinearAddress.exists = true;
        }
        
        /**********************************************************************/
        /** Turns on segment addressing mode during encoding.
        * Uses the Segment Address Record during encoding.
        ***********************************************************************/
        void segmentAddressingOn()
        {
            segmentAddressMode = true;
        }
        
        /**********************************************************************/
        /** Turns on linear addressing mode during encoding.
        * Uses the Linear Address Record during encoding.
        ***********************************************************************/
        void linearAddressingOn()
        {
            segmentAddressMode = false;
        }
        
        /**********************************************************************/
        /** Turns on textual output to cout during decoding.
        * Per record single line output to cout during decoding of Intel HEX
        * files.
        ***********************************************************************/
        void verboseOn()
        {
            verbose = true;
        }
        
        /**********************************************************************/
        /** Turns off textual output to cout during decoding.
        * No output to cout during decoding of Intel HEX files.
        ***********************************************************************/
        void verboseOff()
        {
            verbose = false;
        }
};
#endif

