/*******************************************************************************
* intelhexclass - class definitions                                            *
*                                                                              *
* A class to handle the encoding and decoding of an Intel HEX format file as   *
* generated by many tool chains for embedded processors and microcontrollers.  *
*                                                                              *
* This class is constructed based upon the definition given in the document    *
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988, *
* © 1998 Intel Corporation                                                     *
*------------------------------------------------------------------------------*
* class intelhex                                                               *
*   Member Functions:                                                          *
*                                                                              *
*******************************************************************************/
/*******************************************************************************
*
* CIRCULAR BUFFER MODULE
*
*******************************************************************************/

/******************************************************************************/
/**
* \file intelhexclass.hpp
* \author Stuart Cording aka CODINGHEAD 
* 
* A class to handle the encoding and decoding of an Intel HEX format file as
* generated by many tool chains for embedded processors and microcontrollers.
*
* This class is constructed based upon the definition given in the document
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988,
* © 1998 Intel Corporation.
********************************************************************************
* \note See the git versioning notes for version information
*
*******************************************************************************/

/*******************************************************************************
*
*                            INTEL HEX CLASS MODULE
*
*******************************************************************************/

#ifndef INTELHEXCLASS_MODULE_PRESENT__
#define INTELHEXCLASS_MODULE_PRESENT__

/*******************************************************************************
*                                 INCLUDE FILES
*******************************************************************************/
#include <iostream>
#include <map>
#include <list>

/*******************************************************************************
*                                    EXTERNS
*******************************************************************************/


/*******************************************************************************
*                             DEFAULT CONFIGURATION
*******************************************************************************/


/*******************************************************************************
*                                    DEFINES
*******************************************************************************/

using namespace std;

class intelhex {
        /* Output stream operator to encode contents                          */
        friend ostream& operator<<(ostream& dataOut, 
                                   const intelhex& intelhexData);
        
        /* Input stream to decode contents                                    */
        friend istream& operator>>(istream& dataIn, 
                                   intelhex& intelhexData);

    private:
        /* Stores the addresses and their data of the HEX file                */
        map<unsigned long, unsigned char> ihContent;
        
        /* Iterator for Intel HEX Content map                                 */
        map<unsigned long, unsigned char>::iterator ihIterator;
        
        /* Return value for handling results of map operations                */
        pair<map<unsigned long, unsigned char>::iterator,bool> ihReturn;
  
        /* Stores the segment base address                                    */
        unsigned long segmentBaseAddress;
        
        /* Stores the CS register value for a 'Start Segment Address Record'  */
        unsigned short csRegister;
        
        /* Stores the IP register value for a 'Start Segment Address Record'  */
        unsigned short ipRegister;
        
        /* Stores the EIP register value for a 'Start Linear Address Record'  */
        unsigned long eipRegister;
        
        /* Converts a 2 char string to its HEX value                          */
        unsigned char stringToHex(string value);
        
        /* Converts an unsigned long to a string in HEX format                */
        string ulToHexString(unsigned long value);
        
        /* Converts an unsigned char to a string in HEX format                */
        string ucToHexString(unsigned char value);
        
        /* Converts an unsigned long to a string in DEC format                */
        string ulToString(unsigned long value);
        
        /* Convert the data content of a data record                          */
        void decodeDataRecord(unsigned char recordLength,
                              unsigned long loadOffset, 
                              string::const_iterator data);
                              
        /* Add a warning message                                              */
        void addWarning(string warningMessage);
        
        /* Add an error message                                               */
        void addError(string errorMessage);
        
        /* Select verbose mode during development                             */
        bool verbose;
        
    public:
        /* Vector to hold warning messages                                    */
        list<string> ihWarnings;
        /* Variable to hold number of warning messages                        */
        unsigned long noOfWarnings;
        /* Vector to hold error messages                                      */
        list<string> ihErrors;
        /* Variable to hold number of error messages                          */
        unsigned long noOfErrors;
        
        /* Constructor                                                        */
        intelhex()
        {
            /* Initialise the segment base address to zero                            */
            segmentBaseAddress = 0;
            /* Clear content of register variables used with the 'Start Segment' and  */
            /* 'Start Linear' address records                                         */
            ipRegister = 0;
            csRegister = 0;
            eipRegister = 0;
            /* Set up error and warning handling variables                    */
            noOfWarnings = 0;
            noOfErrors = 0;
            /* Set verbose mode to off                                        */
            verbose = false;
        }

        /* Destructor                                                         */
        ~intelhex()
        {
            /* Currently nothing */
        }
        
        void begin();
        
        void end();
        
        bool jumpTo(unsigned long address)
        {
            bool returnValue = false;
            
            if(ihContent.find(address) != ihContent.end())
            {
                returnValue = true;
                segmentBaseAddress = address;
            }
            return returnValue;
        }
        
        unsigned long currentAddress()
        {
            return segmentBaseAddress;
        }
        
        unsigned long startAddress()
        {
            map<unsigned long, unsigned char>::iterator localIterator;
            
            localIterator = ihContent.begin();
            return (*localIterator).first;
        }
        
        unsigned long endAddress()
        {
            map<unsigned long, unsigned char>::iterator localIterator;
            
            localIterator = ihContent.end();
            return (*localIterator).first;
        }

        unsigned char getData();
        
        bool insertData(unsigned char data);
        
        bool blankFill(unsigned char data);
        
        bool blankFill(unsigned char * const data, unsigned long sizeOfData);
        
        void blankFill(unsigned char * const data, unsigned long sizeOfData,
                       unsigned long endAddress);
        
        bool blankFillRandom();
        
        void blankFillRandom(unsigned long endAddress);
        
        bool blankFillAddressLowByte();
        
        void blankFillAddressLowByte(unsigned long endAddress);
        
        void verboseOn()
        {
            verbose = true;
        }
        
        void verboseOff()
        {
            verbose = false;
        }
};
#endif

