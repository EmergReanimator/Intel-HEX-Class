/*******************************************************************************
* intelhexclass - class definitions                                            *
*                                                                              *
* A class to handle the encoding and decoding of an Intel HEX format file as   *
* generated by many tool chains for embedded processors and microcontrollers.  *
*                                                                              *
* This class is constructed based upon the definition given in the document    *
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988, *
* © 1998 Intel Corporation                                                     *
*------------------------------------------------------------------------------*
* class intelhex                                                               *
*   Member Functions:                                                          *
*                                                                              *
*******************************************************************************/
/*******************************************************************************
*
* CIRCULAR BUFFER MODULE
*
*******************************************************************************/

/******************************************************************************/
/**
* \file intelhexclass.hpp
* \author Stuart Cording aka CODINGHEAD 
* 
* A class to handle the encoding, decoding and manipulatio of an Intel HEX
* format file as generated by many tool chains for embedded processors and 
* microcontrollers.
*
* This class is constructed based upon the definition given in the document
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988,
* © 1998 Intel Corporation.
********************************************************************************
* \note See the git versioning notes for version information
*
*******************************************************************************/

/*******************************************************************************
*
*                            INTEL HEX CLASS MODULE
*
*******************************************************************************/

#ifndef INTELHEXCLASS_MODULE_PRESENT__
#define INTELHEXCLASS_MODULE_PRESENT__

/*******************************************************************************
*                                 INCLUDE FILES
*******************************************************************************/
#include <iostream>
#include <map>
#include <list>

/*******************************************************************************
*                                    EXTERNS
*******************************************************************************/


/*******************************************************************************
*                             DEFAULT CONFIGURATION
*******************************************************************************/


/*******************************************************************************
*                                    DEFINES
*******************************************************************************/

using namespace std;

/******************************************************************************/
/** \cond
* class - intelhex
* \endcond
*
* \brief Class to decode, encode and manipulate Intel HEX format files.
*
* The Intel HEX class allows the user to stream in the content of an Intel HEX
* file so that its content can by analysed more easily than trying to decode
* the Intel HEX file in a text editor. In conjunction with a suitable 
* application it is possible to create content, analyse content and even compare
* the content of files with one another.
*******************************************************************************/
class intelhex {
        /**********************************************************************/
        /** Output stream overload operator.                                   
        * Operator overloaded to encode any data held in memory into the Intel
        * HEX format for storage on disk                 
        *
        * \sa operator>>()
        *
        * \param dataOut    - Output stream for to store the decoded file 
        *                     information
        * \param ihLocal    - Points to this class so that friend function has
        *                     access to private class members
        ***********************************************************************/
        friend ostream& operator<<(ostream& dataOut, 
                                   const intelhex& ihLocal);
        
        /**********************************************************************/
        /** Input stream overload operator.                                   
        * Operator overloaded to decode data streamed in from a file in the 
        * Intel HEX format into memory                 
        *
        * \sa operator<<()
        *
        * \param dataIn     - Input stream for the encoded file information
        * \param ihLocal    - Points to this class so that friend function has
        *                     access to private class members
        ***********************************************************************/
        friend istream& operator>>(istream& dataIn, 
                                   intelhex& ihLocal);

    private:
        /**********************************************************************/
        /** Container for decoded Intel HEX content.                                 
        * STL map holding the addresses found in the Intel HEX file and the
        * associated data byte stored at that address                 
        ***********************************************************************/
        map<unsigned long, unsigned char> ihContent;
        
        /**********************************************************************/
        /** Iterator for the container holding the decoded Intel HEX content. 
        ***********************************************************************/
        map<unsigned long, unsigned char>::iterator ihIterator;
        
        /**********************************************************************/
        /** Pair for the container holding the decoded Intel HEX content. 
        * This is used to acquire the result of an attempt to insert new data
        * into ihContent. Since the ihContent is a map STL, it can't allow
        * data to be assigned to the same address more than once. In this way we
        * can ensure that no address in a file is falsely assigned data more 
        * than once.
        ***********************************************************************/
        pair<map<unsigned long, unsigned char>::iterator,bool> ihReturn;
  
        /**********************************************************************/
        /** Stores segment base address of Intel HEX file.
        * The segment base address is a 32-bit address to which the current
        * load offset (as found in a Data Record line of the Intel HEX file) is
        * added to calculate the actual address of the data. The Data Records
        * can only point to a 64kByte address, so the segment base address 
        * expands the addressing to 4GB. This variable always holds the last
        * address accessed.
        ***********************************************************************/
        unsigned long segmentBaseAddress;
        
        /**********************************************************************/
        /** Stores the content of the CS/IP Registers, if used.
        * Used to store the content of the CS and IS Register for HEX files 
        * created for x386 or earlier Intel processors. This information is 
        * retrieved from the Start Segment Address Record.
        * The found element defines if these registers hold valid data or not.
        ***********************************************************************/
        struct {
            unsigned short  csRegister;
            unsigned short  ipRegister;
            bool            found;
        } startSegmentAddress;
        
        /**********************************************************************/
        /** Stores the content of the EIP Register, if used.
        * Used to store the content of the EIP Register for HEX files created for
        * x386 or earlier Intel processors. This information is retrieved from
        * the Start Linear Address Record.
        * The found element defines if this register holds valid data or not.
        ***********************************************************************/
        struct {
            unsigned long   eipRegister;
            bool            found;
        } startLinearAddress;
        
        
        /**********************************************************************/
        /** Vector to hold warning messages
        * Holds warning messages generated during encoding/decoding process
        ***********************************************************************/
        list<string> ihWarnings;
        
        /**********************************************************************/
        /** Variable to hold number of warning messages
        * Holds current number of warning messages that can be read out
        ***********************************************************************/
        unsigned long noOfWarnings;
        
        /**********************************************************************/
        /** Vector to hold error messages
        * Holds error messages generated during encoding/decoding process
        ***********************************************************************/
        list<string> ihErrors;
        
        /**********************************************************************/
        /** Variable to hold number of error messages
        * Holds current number of error messages that can be read out
        ***********************************************************************/
        unsigned long noOfErrors;
        
        /**********************************************************************/
        /** Select verbose mode
        * Used during development to display messages as the incoming data 
        * stream is decoded                
        ***********************************************************************/
        bool verbose;

        /**********************************************************************/        
        /** Converts a 2 char string to its HEX value
        ***********************************************************************/
        unsigned char stringToHex(string value);

        /**********************************************************************/        
        /** Converts an unsigned long to a string in HEX format               
        ***********************************************************************/
        string ulToHexString(unsigned long value);

        /**********************************************************************/        
        /** Converts an unsigned char to a string in HEX format               
        ***********************************************************************/
        string ucToHexString(unsigned char value);
        
        /**********************************************************************/
        /** Converts an unsigned long to a string in DEC format               
        ***********************************************************************/
        string ulToString(unsigned long value);
        
        /**********************************************************************/
        /** Decodes the data content of a data record                         
        * Takes the data element of a data record in string format, converts
        * each 2 char element into a single byte and then inserts that byte of
        * data into the ihContent STL map.
        *
        * \sa encodeDataRecord()
        *
        * \param recordLength   - Number of bytes in this record as extracted
        *                         from this line in the Intel HEX file
        * \param loadOffset     - The offset from the segment base address for 
        *                         the first byte in this record
        * \param data           - The data content of the record in a string
        ***********************************************************************/
        void decodeDataRecord(unsigned char recordLength,
                              unsigned long loadOffset, 
                              string::const_iterator data);
                              
        /**********************************************************************/
        /** Add a warning message to the warning message list                
        ***********************************************************************/
        void addWarning(string warningMessage);
        
        /**********************************************************************/
        /** Add an error message to the error message list                
        ***********************************************************************/
        void addError(string errorMessage);
        
    public:
        /**********************************************************************/
        /** intelhex Class Constructor
        * Important initialisation steps performed here:
        * - clear segment base address to zero
        * - clear all x86 start address registers to zero
        * - note that there are, as yet, no errors or warnings
        * - set verbode mode to 'false' (default)
        ***********************************************************************/
        intelhex()
        {
            /* Initialise the segment base address to zero                    */
            segmentBaseAddress = 0;
            /* Clear content of register variables used with the 'Start Segment'
            *  and 'Start Linear' address records                             */
            startSegmentAddress.ipRegister = 0;
            startSegmentAddress.csRegister = 0;
            startSegmentAddress.found = false;
            startLinearAddress.eipRegister = 0;
            startLinearAddress.found = false;
            /* Set up error and warning handling variables                    */
            noOfWarnings = 0;
            noOfErrors = 0;
            /* Set verbose mode to off                                        */
            verbose = false;
        }

        /* Destructor                                                         */
        ~intelhex()
        {
            /* Currently nothing */
        }
        
        void begin();
        
        void end();
        
        bool jumpTo(unsigned long address)
        {
            bool returnValue = false;
            
            if(ihContent.find(address) != ihContent.end())
            {
                returnValue = true;
                segmentBaseAddress = address;
            }
            return returnValue;
        }
        
        unsigned long currentAddress()
        {
            return segmentBaseAddress;
        }
        
        unsigned long startAddress()
        {
            map<unsigned long, unsigned char>::iterator localIterator;
            
            localIterator = ihContent.begin();
            return (*localIterator).first;
        }
        
        unsigned long endAddress()
        {
            map<unsigned long, unsigned char>::iterator localIterator;
            
            localIterator = ihContent.end();
            return (*localIterator).first;
        }

        unsigned char getData();
        
        bool insertData(unsigned char data);
        
        bool blankFill(unsigned char data);
        
        bool blankFill(unsigned char * const data, unsigned long sizeOfData);
        
        void blankFill(unsigned char * const data, unsigned long sizeOfData,
                       unsigned long endAddress);
        
        bool blankFillRandom();
        
        void blankFillRandom(unsigned long endAddress);
        
        bool blankFillAddressLowByte();
        
        void blankFillAddressLowByte(unsigned long endAddress);
        
        unsigned short getNoWarnings();
        
        unsigned short getNoErrors();
        
        bool popNextWarning(string& warning);
        
        bool popNextError(string& error);
        
        bool getSegmentStartAddress(unsigned short * ipRegister, unsigned short * esRegister);
        
        bool getSegmentLinearAddress(unsigned long * eipRegister);
        
        void setSegmentStartAddress(unsigned short ipRegister, unsigned short esRegister);
        
        void setSegmentLinearAddress(unsigned long eipRegister);
        
        void verboseOn()
        {
            verbose = true;
        }
        
        void verboseOff()
        {
            verbose = false;
        }
};
#endif

