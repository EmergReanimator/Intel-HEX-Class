/*******************************************************************************
* intelhexclass - class definitions                                            *
*                                                                              *
* A class to handle the encoding and decoding of an Intel HEX format file as   *
* generated by many tool chains for embedded processors and microcontrollers.  *
*                                                                              *
* This class is constructed based upon the definition given in the document    *
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988, *
* © 1998 Intel Corporation                                                     *
*------------------------------------------------------------------------------*
* class intelhex                                                               *
*   Member Functions:                                                          *
*                                                                              *
*******************************************************************************/
/*******************************************************************************
*
* CIRCULAR BUFFER MODULE
*
*******************************************************************************/

/******************************************************************************/
/**
* \file intelhexclass.hpp
* \author Stuart Cording aka CODINGHEAD 
* 
* A class to handle the encoding, decoding and manipulatio of an Intel HEX
* format file as generated by many tool chains for embedded processors and 
* microcontrollers.
*
* This class is constructed based upon the definition given in the document
* 'Hexadecimal Object File Format Specification', Revision A, January 6, 1988,
* © 1998 Intel Corporation.
********************************************************************************
* \note See the git versioning notes for version information
*
*******************************************************************************/

/*******************************************************************************
*
*                            INTEL HEX CLASS MODULE
*
*******************************************************************************/

#ifndef INTELHEXCLASS_MODULE_PRESENT__
#define INTELHEXCLASS_MODULE_PRESENT__

/*******************************************************************************
*                                 INCLUDE FILES
*******************************************************************************/
#include <iostream>
#include <map>
#include <list>

/*******************************************************************************
*                                    EXTERNS
*******************************************************************************/


/*******************************************************************************
*                             DEFAULT CONFIGURATION
*******************************************************************************/


/*******************************************************************************
*                                    DEFINES
*******************************************************************************/

using namespace std;

/******************************************************************************/
/** \cond
* class - intelhex
* \endcond
*
* \brief Class to decode, encode and manipulate Intel HEX format files.
*
* The Intel HEX class allows the user to stream in the content of an Intel HEX
* file so that its content can by analysed more easily than trying to decode
* the Intel HEX file in a text editor. In conjunction with a suitable 
* application it is possible to create content, analyse content and even compare
* the content of files with one another.
*******************************************************************************/
class intelhex {
        /**********************************************************************/
        /** Output stream overload operator.                                   
        * Operator overloaded to encode any data held in memory into the Intel
        * HEX format for storage on disk                 
        *
        * \sa operator>>()
        *
        * \param dataOut    - Output stream for to store the decoded file 
        *                     information
        * \param ihLocal    - Points to this class so that friend function has
        *                     access to private class members
        ***********************************************************************/
        friend ostream& operator<<(ostream& dataOut, 
                                   const intelhex& ihLocal);
        
        /**********************************************************************/
        /** Input stream overload operator.                                   
        * Operator overloaded to decode data streamed in from a file in the 
        * Intel HEX format into memory                 
        *
        * \sa operator<<()
        *
        * \param dataIn     - Input stream for the encoded file information
        * \param ihLocal    - Points to this class so that friend function has
        *                     access to private class members
        ***********************************************************************/
        friend istream& operator>>(istream& dataIn, 
                                   intelhex& ihLocal);

    private:
        /**********************************************************************/
        /** Container for decoded Intel HEX content.                                 
        * STL map holding the addresses found in the Intel HEX file and the
        * associated data byte stored at that address                 
        ***********************************************************************/
        map<unsigned long, unsigned char> ihContent;
        
        /**********************************************************************/
        /** Iterator for the container holding the decoded Intel HEX content. 
        ***********************************************************************/
        map<unsigned long, unsigned char>::iterator ihIterator;
        
        /**********************************************************************/
        /** Pair for the container holding the decoded Intel HEX content. 
        * This is used to acquire the result of an attempt to insert new data
        * into ihContent. Since the ihContent is a map STL, it can't allow
        * data to be assigned to the same address more than once. In this way we
        * can ensure that no address in a file is falsely assigned data more 
        * than once.
        ***********************************************************************/
        pair<map<unsigned long, unsigned char>::iterator,bool> ihReturn;
  
        /**********************************************************************/
        /** Stores segment base address of Intel HEX file.
        * The segment base address is a 32-bit address to which the current
        * load offset (as found in a Data Record line of the Intel HEX file) is
        * added to calculate the actual address of the data. The Data Records
        * can only point to a 64kByte address, so the segment base address 
        * expands the addressing to 4GB. This variable always holds the last
        * address accessed.
        ***********************************************************************/
        unsigned long segmentBaseAddress;
        
        /**********************************************************************/
        /** Stores the content of the CS Register.
        * Used to store the content of the CS Register for HEX files created for
        * x386 or earlier Intel processors. This information is retrieved from
        * the Start Segment Address Record.
        ***********************************************************************/
        unsigned short csRegister;
        
        /**********************************************************************/
        /** Stores the content of the IP Register.
        * Used to store the content of the IP Register for HEX files created for
        * x386 or earlier Intel processors. This information is retrieved from
        * the Start Segment Address Record.
        ***********************************************************************/
        unsigned short ipRegister;
        
        /**********************************************************************/
        /** Stores the content of the EIP Register.
        * Used to store the content of the EIP Register for HEX files created for
        * x386 or earlier Intel processors. This information is retrieved from
        * the Start Linear Address Record.
        ***********************************************************************/
        unsigned long eipRegister;
        
        /** Converts a 2 char string to its HEX value                         */
        unsigned char stringToHex(string value);
        
        /** Converts an unsigned long to a string in HEX format               */
        string ulToHexString(unsigned long value);
        
        /** Converts an unsigned char to a string in HEX format               */
        string ucToHexString(unsigned char value);
        
        /** Converts an unsigned long to a string in DEC format               */
        string ulToString(unsigned long value);
        
        /** Decodes the data content of a data record                         */
        void decodeDataRecord(unsigned char recordLength,
                              unsigned long loadOffset, 
                              string::const_iterator data);
                              
        /** Add a warning message to the warning message list                 */
        void addWarning(string warningMessage);
        
        /** Add an error message to the error message list                    */
        void addError(string errorMessage);
        
        /**********************************************************************/
        /** Select verbose mode
        * Used during development to display messages as the incoming data 
        * stream is decoded                
        ***********************************************************************/
        bool verbose;
        
        /* Vector to hold warning messages                                    */
        list<string> ihWarnings;
        /* Variable to hold number of warning messages                        */
        unsigned long noOfWarnings;
        /* Vector to hold error messages                                      */
        list<string> ihErrors;
        /* Variable to hold number of error messages                          */
        unsigned long noOfErrors;
        
    public:
        /* Constructor                                                        */
        intelhex()
        {
            /* Initialise the segment base address to zero                            */
            segmentBaseAddress = 0;
            /* Clear content of register variables used with the 'Start Segment' and  */
            /* 'Start Linear' address records                                         */
            ipRegister = 0;
            csRegister = 0;
            eipRegister = 0;
            /* Set up error and warning handling variables                    */
            noOfWarnings = 0;
            noOfErrors = 0;
            /* Set verbose mode to off                                        */
            verbose = false;
        }

        /* Destructor                                                         */
        ~intelhex()
        {
            /* Currently nothing */
        }
        
        void begin();
        
        void end();
        
        bool jumpTo(unsigned long address)
        {
            bool returnValue = false;
            
            if(ihContent.find(address) != ihContent.end())
            {
                returnValue = true;
                segmentBaseAddress = address;
            }
            return returnValue;
        }
        
        unsigned long currentAddress()
        {
            return segmentBaseAddress;
        }
        
        unsigned long startAddress()
        {
            map<unsigned long, unsigned char>::iterator localIterator;
            
            localIterator = ihContent.begin();
            return (*localIterator).first;
        }
        
        unsigned long endAddress()
        {
            map<unsigned long, unsigned char>::iterator localIterator;
            
            localIterator = ihContent.end();
            return (*localIterator).first;
        }

        unsigned char getData();
        
        bool insertData(unsigned char data);
        
        bool blankFill(unsigned char data);
        
        bool blankFill(unsigned char * const data, unsigned long sizeOfData);
        
        void blankFill(unsigned char * const data, unsigned long sizeOfData,
                       unsigned long endAddress);
        
        bool blankFillRandom();
        
        void blankFillRandom(unsigned long endAddress);
        
        bool blankFillAddressLowByte();
        
        void blankFillAddressLowByte(unsigned long endAddress);
        
        void verboseOn()
        {
            verbose = true;
        }
        
        void verboseOff()
        {
            verbose = false;
        }
};
#endif

